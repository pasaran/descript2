# Options

См. [jpath expressions](./jexpr.md).


## `options.isolate_state`

Позволяет скрыть богатую внутреннюю жизнь блока в стейте:

```js
//  b1
de.object( {

    block: {
        //  b2
        foo: de.block( {
            id: 'foo',
            block: ...,
            options: {
                select: {
                    id: de.jexpr( '.id' )
                }
            }
        } ),

        //  b3
        bar: de.block( {
            block: ...,
            options: {
                deps: 'foo',
                params: {
                    id: de.jexpr( 'state.id' )
                }
            }
        } )

    },

    options: {
        isolate_state: true,
        select: {
            count: '.bar.count'
        }
    }

} )
```

Здесь у блока `b1` есть два подблока: `b2` и `b3`, который зависит от `b2`.
`b2` после получения результата кладет в стейт некий `id`, а `b3` использует его
в качестве параметра. Но снаружи блока `b1` никому не нужно знать про этот `id`
и незачем загрязнять стейт. Поэтому мы используем `options.isolate_state`.
При запуске `b1` текущий на тот момент стейт копируется, `b2` и `b3` работают с копией.
Но после всего этого блок `b1` кладет в стейт значение `count` — и вот тут уже используется
не копия, а исходный стейт.


## `options.deps`

См. подробности про [зависимости](./deps.md).


## `options.guard`

Гард — это функция, с помощью которой можно управлять тем,
выполнять ли блок или нет в зависимости от параметров, стейта и т.д.
Если гард задан и его вычисленное значение оказывается ложным, то блок не выполняется,
а результатом выполнения блока будет ошибка типа `BLOCK_GUARDED`:

```js
    {
        id: 'BLOCK_GUARDED',
        message: 'Block guarded'
    }
```

Пример:

```js
guard: function( params, context, state ) {
    return context.req.method === 'POST' && state.id;
}

guard: de.jexpr( 'context.req.method === "POST" && state.id' )
```

Гард должен быть синхронным. См. `options.before`.


## `options.before`

Пре-валидация. Перед тем, как выполнять блок, можно проверить,
все ли необходимые для этого условия выполнены:

```js
before: function( params, context, state ) {
    if ( !params.id ) {
        return de.error( {
            id: 'INCORRECT_PARAMS',
            message: 'id param is missing'
        } );
    }
}

before: function( params ) {
    if ( !params.id ) {
        context.redirect( ... );
    }
}
```

Разница между `options.guard` и `options.before` в том, что если сработал гард,
то это не считается ошибкой. И, например, если блок имел `options.required`, но был
пропущен из-за гарда, то это не приведет к общей ошибке родительского блока.

Второе отличие: `guard` всегда синхронный, а `before` может вернуть промис:

```js
before: function() {
    const promise = de.promise();

    ...
        promise.resolve( de.error( ... ) );

    return promise;
}
```


## `options.key`, `options.maxage`, `options.cache`

Позволяет закэшировать блок:

```js
key: function( params, context, state ) {
    return params.id;
},
maxage: 86400

key: de.jstring( '{ params.mark_id }:{ params.model_id }' ),
maxage: 3600
```

По дефолту для кэширования используется объект `context.cache`
(если он существует), который должен иметь методы `get` и `set`:

    context.cache.get( key )
    context.cache.set( key, value, maxage )

См. подробнее про [кэширование](./cache.md).
`maxage` по идее задается в секундах, но на деле важно лишь,
чтобы это соответствовало тому, что принимает кэш.

Можно разные блоки кэшировать по-разному (например, один в памяти, другой в memcached),
задавая явно объект с кэшом:

```js
key: ...,
maxage: ...,
cache: my_cache
```


## `options.timeout`

Таймаут блока в миллисекундах:

```js
timeout: 1000
```

Если блок не укладывается в указанный таймаут, то он завершается с ошибкой типа `BLOCK_TIMED_OUT`.
При этом по возможности прекращается все, что блок делал до этого. Если это был http-блок, то запрос обрывается,
если это был array- или object-блок, то все подблоки так же останавливаются. Конечно, не все можно остановить.
Например, чтение из файла нельзя. Кроме того, для кастомных func-блоков нужно предусмотреть отдельно
возможность остановить запрос по запросу. См. [func-блок](./block.func.md).


## `options.params` и `options.valid_params`

Перед самым началом выполнения экшена (http-запрос, чтение из файла, ...) вычисляются новые параметры.
Те параметры, которые пришли в блок изначально не всегда соответствуют тому, что нужно для экшена.
Например, в блок пришел весь входящий набор параметров, которые мы распарсили из урла, но для http-запроса
все эти параметры не нужны. Нужна лишь часть, или же часть параметров нужно вычислить каким-либо образом.

В `params` мы описываем, как именно получать необходимые параметры.
Это может быть просто функция, которая возвращает набор параметров:

```js
params: function( params, context, state ) {
    return {
        page_size: 10,
        page_number: params.page,
        mark_id: state.mark_id,
        sale_id: params.id
    };
}
```

Или же это объект:

```js
params: {
    page_size: 10,
    page_number: function( params, context, state ) {
        return params.page;
    },
    mark_id: de.jexpr( 'state.mark_id' ),
    sale_id: de.jexpr( 'params.id' )
}
```

В этом объекте значениями могут быть либо функции (их значение вычисляется),
либо просто константные значения.

В `valid_params` мы можем описать, какие вообще параметры допустимы:

```js
valid_params: {
    mark_id: null,
    sale_id: null,
    page_number: 0,
    page_size: 20
}
```

Здесь не `null` означает дефолтное значение параметра.

Схема такая. Сперва мы берем объект с параметрами, переданными в блок в метод `_run`.
Выкидываем из него (точнее тут создается копия) все ключи со значениями `null` или `undefined`.
Дальше, если `options.params` это функция, результатом ее выполнения мы расширяем эту копию.
Если не функция, то каждое значение вычисляется (или берется как есть) с учетом дефолтных значений
и так же добавляется в копию оригинальных параметров.
Дальше, если есть `options.valid_params`, то из результата отфильтровывается все, что не упомянуто
в `valid_params`.
Может быть так, что у блока есть несколько пар `params/valid_params` — если он был [расширен](./extend.md).
В этом случае процедура повторяется N раз, но на вход подаются уже не оригинальные параметры, а то,
что получилось на предыдущем шаге.

Пример:

```js
b1 = de.block( {
    block: ...,
    options: {
        valid_params: {
            foo: 42,
            bar: null
        }
    }
} )

b2 = b1( {
    options: {
        params: {
            bar: de.jexpr( 'params.quu' )
        }
    }
} )

context.run( b2, { quu: 24, boo: null } )
```

На нулевом шаге отбрасываем все значения с `null` и `undefined`:

```js
{
    quu: 24
}
```

После первого шага у нас получится объект:

```js
{
    quu: 24,
    bar: 24
}
```

На втором шаге, мы добавим `foo: 42` (дефолтное значение),
но отфильтруем `quu: 42`, так как оно не входит в набор разрешенных параметров.
Получаем:

```js
{
    foo: 42,
    bar: 24
}
```


## action

После вычисления параметров запускается собственно экшен: http-запрос, чтение файла, ...
И во всех последующих колбэках четвертым параметром будет приходить результат
выполнения этого экшена. А первым — уже новые параметры, вычисленные на
предыдущем шаге.

## `options.select`

Возможность достать что-то из результата (параметров, стейта, контекста, ...)
и положить в стейт, чтобы, например, этим могли воспользоваться другие блоки:

```js
select: {
    mark_id: de.jexpr( '.result.mark.id' )
}
```

**Важно**. Если в стейте с этим ключом уже было значение и это был массив,
то вычисленный результат не перезатирает старый, а добавляется к этому массиву.
Например, у нас есть несколько блоков, мы ходим достать из их результатов какие-то
наборы id-шников, а потом, в самом конце, сделать один batch-запрос с ними:

```js
de.object( {

    block: {
        foo: de.block( {
            ...
            options: {
                select: {
                    //  Здесь у нас выберется массив (скорее всего).
                    ids: de.jexpr( '.items.id' )
                }
            }
        },
        bar: de.block( {
            ...
            options: {
                select: {
                    //  Здесь добавляется одиночный id.
                    ids: de.jexpr( '.result.id' )
                }
            }
        },

        quu: de.block( {
            ...
            options: {
                //  Ждем, пока все остальные блоки выполнятся.
                priority: -10,
                params: {
                    //  Отправляем все ids, которые накопились в стейте.
                    ids: de.jexpr( 'state.ids' )
                }
            }
        } )
    },

    options: {
        before: function( params, context, state ) {
            //  Инициализируем значение массивом.
            state.ids = [];
        }
    }

} )
```


## `options.after`

Пост-валидация. То же самое, что и `befire`, но `after`.
Можно вернуть ошибку, если результат неверный, можно закончить работу с ошибкой или редиректом,
выставить куки, положить что-то  в стейт и т.д.

```js
after: function( params, context, state, result ) {
    if ( !result.id ) {
        return de.error( {
            id: 'NOT_FOUND',
            message: 'Page not found',
            status_code: 404
        } );
    }
}
```


## `options.result`

Пост-обработка. Возможность как-то модифицировать результат выполнения блока:

```js
//  Вытащить какой-то кусок полученного объекта.
result: de.jexpr( '.result.mark' )

//  Собрать только нужное из собственно результата, стейта, параметров и т.д.
result: function( params, context, state, result ) {
    return {
        id: params.id,
        foo: result.foo
    };
}
```

Эта функция вызывается синхронно.


## `options.template`

В сущности то же самое, что и `options.result`, но может быть асинхронным.
Кажется, нужно оставить что-то одно.


