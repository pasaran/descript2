# Options

См. [jpath expressions](./jexpr.md).


## `options.isolate_state`

Позволяет скрыть богатую внутреннюю жизнь блока в стейте:

    //  b1
    de.object( {

        block: {
            //  b2
            foo: de.block( {
                id: 'foo',
                block: ...,
                options: {
                    select: {
                        id: de.jexpr( '.id' )
                    }
                }
            } ),

            //  b3
            bar: de.block( {
                block: ...,
                options: {
                    deps: 'foo',
                    params: {
                        id: de.jexpr( 'state.id' )
                    }
                }
            } )

        },

        options: {
            isolate_state: true,
            select: {
                count: de.jexpr('.bar.count')
            }
        }

    } )

Здесь у блока `b1` есть два подблока: `b2` и `b3`, который зависит от `b2`.
`b2` после получения результата кладет в стейт некий `id`, а `b3` использует его
в качестве параметра. Но снаружи блока `b1` никому не нужно знать про этот `id`
и незачем загрязнять стейт. Поэтому мы используем `options.isolate_state`.
При запуске `b1` текущий на тот момент стейт копируется, `b2` и `b3` работают с копией.
Но после всего этого блок `b1` кладет в стейт значение `count` — и вот тут уже используется
не копия, а исходный стейт.


## `options.deps`

См. подробности про [зависимости](./deps.md).


## `options.guard`

Гард — это функция, с помощью которой можно управлять тем,
выполнять ли блок или нет в зависимости от параметров, стейта и т.д.
Если гард задан и его вычисленное значение оказывается ложным, то блок не выполняется,
а результатом выполнения блока будет ошибка типа `BLOCK_GUARDED`:

    {
        id: 'BLOCK_GUARDED',
        message: 'Block guarded'
    }

Пример:

    guard: function( params, context, state ) {
        return context.req.method === 'POST' && state.id;
    }

    guard: de.jexpr( 'context.req.method === "POST" && state.id' )

Гард должен быть синхронным. См. `options.before`.


## `options.before`

Пре-валидация. Перед тем, как выполнять блок, можно проверить,
все ли необходимые для этого условия выполнены:

    before: function( params, context, state ) {
        if ( !params.id ) {
            return de.error( {
                id: 'INCORRECT_PARAMS',
                message: 'id param is missing'
            } );
        }
    }

    before: function( params ) {
        if ( !params.id ) {
            context.redirect( ... );
        }
    }

Разница между `options.guard` и `options.before` в том, что если сработал гард,
то это не считается ошибкой. И, например, если блок имел `options.required`, но был
пропущен из-за гарда, то это не приведет к общей ошибке родительского блока.

Второе отличие: `guard` всегда синхронный, а `before` может вернуть промис:

    before: function() {
        const promise = de.promise();

        ...
            promise.resolve( de.error( ... ) );

        return promise;
    }


## `options.key`, `options.maxage`, `options.cache`

Позволяет закэшировать блок:

    key: function( params, context, state ) {
        return params.id;
    },
    maxage: 86400

    key: de.jstring( '{ params.mark_id }:{ params.model_id }' ),
    maxage: 3600

По дефолту для кэширования используется объект `context.cache`
(если он существует), который должен иметь методы `get` и `set`:

    context.cache.get( key )
    context.cache.set( key, value, maxage )

См. подробнее про [кэширование](./cache.md).
`maxage` по идее задается в секундах, но на деле важно лишь,
чтобы это соответствовало тому, что принимает кэш.

Можно разные блоки кэшировать по-разному (например, один в памяти, другой в memcached),
задавая явно объект с кэшом:

    key: ...,
    maxage: ...,
    cache: my_cache


## `options.timeout`

Таймаут блока в миллисекундах:

    timeout: 1000

Если блок не укладывается в указанный таймаут, то он завершается с ошибкой типа `BLOCK_TIMED_OUT`.
При этом по возможности прекращается все, что блок делал до этого. Если это был http-блок, то запрос обрывается,
если это был array- или object-блок, то все подблоки так же останавливаются. Конечно, не все можно остановить.
Например, чтение из файла нельзя. Кроме того, для кастомных func-блоков нужно предусмотреть отдельно
возможность остановить запрос по запросу. См. [func-блок](./block.func.md).


## `options.params` и `options.valid_params`

Перед самым началом выполнения экшена (http-запрос, чтение из файла, ...) вычисляются новые параметры.
Те параметры, которые пришли в блок изначально не всегда соответствуют тому, что нужно для экшена.
Например, в блок пришел весь входящий набор параметров, которые мы распарсили из урла, но для http-запроса
все эти параметры не нужны. Нужна лишь часть, или же часть параметров нужно вычислить каким-либо образом.

В `params` мы описываем, как именно получать необходимые параметры.
Это может быть просто функция, которая возвращает набор параметров:

    params: function( params, context, state ) {
        return {
            page_size: 10,
            page_number: params.page,
            mark_id: state.mark_id,
            sale_id: params.id
        };
    }

Или же это объект:

    params: {
        page_size: 10,
        page_number: function( params, context, state ) {
            return params.page;
        },
        mark_id: de.jexpr( 'state.mark_id' ),
        sale_id: de.jexpr( 'params.id' )
    }

В этом объекте значениями могут быть либо функции (их значение вычисляется),
либо просто константные значения.

В `valid_params` мы можем описать, какие вообще параметры допустимы:

    valid_params: {
        mark_id: null,
        sale_id: null,
        page_number: 0,
        page_size: 20
    }

Здесь не `null` означает дефолтное значение параметра.

Схема такая. Сперва мы берем объект с параметрами, переданными в блок в метод `_run`.
Выкидываем из него (точнее тут создается копия) все ключи со значениями `null` или `undefined`.
Дальше, если `options.params` это функция, результатом ее выполнения мы расширяем эту копию.
Если не функция, то каждое значение вычисляется (или берется как есть) с учетом дефолтных значений
и так же добавляется в копию оригинальных параметров.
Дальше, если есть `options.valid_params`, то из результата отфильтровывается все, что не упомянуто
в `valid_params`.
Может быть так, что у блока есть несколько пар `params/valid_params` — если он был [расширен](./extend.md).
В этом случае процедура повторяется N раз, но на вход подаются уже не оригинальные параметры, а то,
что получилось на предыдущем шаге.

Пример:

    b1 = de.block( {
        block: ...,
        options: {
            valid_params: {
                foo: 42,
                bar: null
            }
        }
    } )

    b2 = b1( {
        options: {
            params: {
                bar: de.jexpr( 'params.quu' )
            }
        }
    } )

    context.run( b2, { quu: 24, boo: null } )

На нулевом шаге отбрасываем все значения с `null` и `undefined`:

    {
        quu: 24
    }

После первого шага у нас получится объект:

    {
        quu: 24,
        bar: 24
    }

На втором шаге, мы добавим `foo: 42` (дефолтное значение),
но отфильтруем `quu: 42`, так как оно не входит в набор разрешенных параметров.
Получаем:

    {
        foo: 42,
        bar: 24
    }


## action

После вычисления параметров запускается собственно экшен: http-запрос, чтение файла, ...
И во всех последующих колбэках четвертым параметром будет приходить результат
выполнения этого экшена. А первым — уже новые параметры, вычисленные на
предыдущем шаге.

## `options.select`

Возможность достать что-то из результата (параметров, стейта, контекста, ...)
и положить в стейт, чтобы, например, этим могли воспользоваться другие блоки:

Берем mark.id из result:

    select: {
        mark_id: de.jexpr( '.mark.id' )
    }

или берем mark_id из params:

    select: {
        mark_id: de.jexpr( 'params.mark_id' )
    }

**Важно**. Если в стейте с этим ключом уже было значение и это был массив,
то вычисленный результат не перезатирает старый, а добавляется к этому массиву.
Например, у нас есть несколько блоков, мы ходим достать из их результатов какие-то
наборы id-шников, а потом, в самом конце, сделать один batch-запрос с ними:

    de.object( {

        block: {
            foo: de.block( {
                ...
                options: {
                    select: {
                        //  Здесь у нас выберется массив (скорее всего).
                        ids: de.jexpr( '.items.id' )
                    }
                }
            },
            bar: de.block( {
                ...
                options: {
                    select: {
                        //  Здесь добавляется одиночный id.
                        ids: de.jexpr( '.id' )
                    }
                }
            },

            quu: de.block( {
                ...
                options: {
                    //  Ждем, пока все остальные блоки выполнятся.
                    priority: -10,
                    params: {
                        //  Отправляем все ids, которые накопились в стейте.
                        ids: de.jexpr( 'state.ids' )
                    }
                }
            } )
        },

        options: {
            before: function( params, context, state ) {
                //  Инициализируем значение массивом.
                state.ids = [];
            }
        }

    } )


## `options.after`

Пост-валидация. То же самое, что и `befire`, но `after`.
Можно вернуть ошибку, если результат неверный, можно закончить работу с ошибкой или редиректом,
выставить куки, положить что-то  в стейт и т.д.

    after: function( params, context, state, result ) {
        if ( !result.id ) {
            return de.error( {
                id: 'NOT_FOUND',
                message: 'Page not found',
                status_code: 404
            } );
        }
    }


## `options.result`

Пост-обработка. Возможность как-то модифицировать результат выполнения блока:

    //  Вытащить какой-то кусок полученного объекта.
    result: de.jexpr( '.result.mark' )

    //  Собрать только нужное из собственно результата, стейта, параметров и т.д.
    result: function( params, context, state, result ) {
        return {
            id: params.id,
            foo: result.foo
        };
    }

Эта функция вызывается синхронно.


## `options.template`

В сущности то же самое, что и `options.result`, но может быть асинхронным.
Кажется, нужно оставить что-то одно.


